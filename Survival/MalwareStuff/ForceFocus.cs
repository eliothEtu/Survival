using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;

namespace Survival.MalwareStuff
{
    public class ForceFocus
    {
        private delegate int HookProc(int nCode, IntPtr wParam, KBDLLHOOKSTRUCT lParam);

        private struct KBDLLHOOKSTRUCT
        {
            public int vkCode;
            public int scanCode;
            public int flags;
            public int time;
            public IntPtr extra;
        }

        [DllImport("user32.dll")]
        private static extern IntPtr SetWindowsHookEx(int filterType, HookProc hook, IntPtr hMod, ulong threadId);

        [DllImport("user32.dll")]
        private static extern int CallNextHookEx(IntPtr hook, int nCode, IntPtr wParam, KBDLLHOOKSTRUCT lParam);
        [DllImport("user32.dll")]
        private static extern bool UnhookWindowsHookEx(IntPtr hook);

        private static IntPtr hook = IntPtr.Zero;

        private static List<Key> BLOCKED_KEYS = new List<Key>
        {
            Key.LeftAlt,
            Key.LeftCtrl,
            Key.LWin
        };

        private static HookProc hookProc;

        public static void EnableLock()
        {
            hookProc = new HookProc(HookCallback);
            hook = SetWindowsHookEx(13, hookProc, Marshal.GetHINSTANCE(typeof(MainWindow).Module), 0);
        }

        public static void DisableLock()
        {
            UnhookWindowsHookEx(hook);
        }

        private static int HookCallback(int nCode, IntPtr wParam, KBDLLHOOKSTRUCT lParam)
        {
            if(nCode >= 0)
            {
                Key key = KeyInterop.KeyFromVirtualKey(lParam.vkCode);

               if(BLOCKED_KEYS.Contains(key))
                {
                   return 1;
                }
            }

            return CallNextHookEx(hook, nCode, wParam, lParam);
        }
    }
}
